<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2025-10-24T14:27:56+02:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Xavi Vico Marti</title><subtitle>An amazing website.</subtitle><author><name>Xavi Vico Marti</name></author><entry><title type="html">Red Hat Enterprise Linux: Integración de RHEL 10 con Active Directory 2019 usando SSSD y realmd</title><link href="http://localhost:4000/redhat/activedirectory/RHEL-Integracion-RHEL-10-con-AD/" rel="alternate" type="text/html" title="Red Hat Enterprise Linux: Integración de RHEL 10 con Active Directory 2019 usando SSSD y realmd" /><published>2025-10-14T00:00:00+02:00</published><updated>2025-10-14T00:00:00+02:00</updated><id>http://localhost:4000/redhat/activedirectory/RHEL-Integracion-RHEL-10-con-AD</id><content type="html" xml:base="http://localhost:4000/redhat/activedirectory/RHEL-Integracion-RHEL-10-con-AD/"><![CDATA[<h1 id="integración-de-rhel-10-con-active-directory-2019-usando-sssd-y-realmd">Integración de RHEL 10 con Active Directory 2019 usando SSSD y realmd</h1>

<h2 id="introducción">Introducción</h2>

<p>La gestión centralizada de identidades y accesos es clave. Microsoft Active Directory (AD) se ha consolidado como el estándar en muchas infraestructuras para esta tarea.</p>

<p>En esta guía, desglosaremos las opciones de integración y veremos paso a paso cómo conectar un sistema RHEL a un dominio de Active Directory.</p>

<h2 id="opciones-de-integración-cuál-elegir">Opciones de Integración: ¿Cuál elegir?</h2>

<p>Existen varias formas de lograr esta integración, cada una con sus particularidades. Aquí te presentamos las principales:</p>

<h3 id="tabla-de-opciones-de-integración">Tabla de opciones de integración</h3>

<table>
  <thead>
    <tr>
      <th>Opción de Integración</th>
      <th>Descripción Técnica</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>System Security Services Daemon (SSSD)</strong></td>
      <td>Es el componente de autenticación y resolución de identidades más moderno y recomendado. Permite a RHEL integrarse de forma nativa con dominios Active Directory utilizando protocolos como Kerberos, LDAP y DNS. Ofrece funcionalidades avanzadas como caché de credenciales, resolución de grupos y usuarios, mapeo de atributos AD a NSS/PAM, y soporte para autenticación offline. SSSD actúa como un middleware entre las aplicaciones del sistema y las fuentes externas de identidad, centralizando la gestión de políticas y sesiones.</td>
    </tr>
    <tr>
      <td><strong>Samba Winbind</strong></td>
      <td>Implementación basada en Samba que permite a los sistemas Linux funcionar como miembros de un dominio Windows/AD. Utiliza protocolos SMB/CIFS, NTLM y Kerberos, proporcionando resolución de usuarios y grupos de dominio a través de nsswitch y PAM. Aunque es funcional, su arquitectura basada en SMB puede implicar una mayor carga y dependencia del stack de Samba en comparación con SSSD.</td>
    </tr>
    <tr>
      <td><strong>Managed Service Account (MSA)</strong></td>
      <td>Una característica de Active Directory que permite crear cuentas de servicio administradas. Diseñada para que aplicaciones o demonios específicos en RHEL se autentiquen contra AD de forma segura sin requerir la unión completa del host al dominio. Las MSA gestionan automáticamente la rotación de contraseñas y las políticas de autenticación mediante Kerberos, reduciendo la sobrecarga administrativa y los riesgos asociados a credenciales estáticas. Ideal para servicios, no para login de usuarios interactivos.</td>
    </tr>
  </tbody>
</table>

<p>En esta guía, nos centraremos en el método más recomendado y versátil para una integración profunda: <strong>SSSD</strong>.</p>

<h2 id="descubriendo-sssd">Descubriendo SSSD</h2>

<p>El <strong>System Security Services Daemon (SSSD)</strong> es un servicio esencial en los sistemas Linux/UNIX que actúa como intermediario inteligente para la gestión de identidad y autenticación. Su propósito es conectar tu sistema local (el “cliente SSSD”) a diversas fuentes de identidad y mecanismos de autenticación remotos (los “proveedores”).</p>

<p>SSSD opera en dos etapas clave:</p>

<ol>
  <li><strong>Conexión con el proveedor remoto:</strong> Se comunica con un proveedor remoto (LDAP, AD, Kerberos, IdM) para obtener información de identidad del usuario (UID, GID, etc.) y datos necesarios para autenticación.</li>
  <li><strong>Caché local de identidad y credenciales:</strong> Crea y mantiene una caché local de esta información, permitiendo autenticación offline y mejor rendimiento.</li>
</ol>

<p>Gracias a esta arquitectura, los usuarios pueden autenticarse en Linux usando cuentas almacenadas en el proveedor remoto sin crear cuentas locales duplicadas. SSSD puede configurarse para crear directorios de inicio automáticamente.</p>

<h3 id="los-pilares-de-la-autenticación-pam-y-nss">Los Pilares de la Autenticación: PAM y NSS</h3>

<p>SSSD obtiene la información de identidad desde un servidor remoto y la almacena localmente. ¿Cómo utiliza el sistema operativo esa información?</p>

<h4 id="pam-pluggable-authentication-modules">PAM (Pluggable Authentication Modules)</h4>

<ul>
  <li><strong>Función:</strong> Autenticación y autorización de usuarios.</li>
  <li><strong>Pregunta clave:</strong> “¿Puede este usuario autenticarse y acceder?”</li>
</ul>

<h4 id="nss-name-service-switch">NSS (Name Service Switch)</h4>

<ul>
  <li><strong>Función:</strong> Define de dónde obtener información sobre usuarios, grupos, hosts, contraseñas, etc.</li>
  <li><strong>Archivo de configuración:</strong> <code class="language-plaintext highlighter-rouge">/etc/nsswitch.conf</code></li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>passwd:     files ldap sss
group:      files ldap sss
shadow:     files ldap sss
hosts:      files dns sss
</code></pre></div></div>
<p>Esto significa que, para passwd (usuarios), el sistema primero busca en /etc/passwd (files), luego en un servidor LDAP (ldap), y finalmente consulta a SSSD (sss).</p>

<ul>
  <li><strong>Pregunta clave:</strong> “¿De dónde obtengo la información de este usuario (UID, GID, nombre)?”</li>
</ul>

<h4 id="flujo-de-autenticación-detallado">Flujo de Autenticación Detallado</h4>

<p><img src="/assets/images/20251024/20251024-01.png" alt="Texto alternativo" /></p>

<h3 id="requisitos-y-opciones-de-mapeo-de-ids">Requisitos y Opciones de Mapeo de IDs</h3>

<h4 id="tipos-de-servidores-de-identidad-compatibles-con-sssd">Tipos de Servidores de Identidad Compatibles con SSSD</h4>

<p>SSSD es altamente versátil y puede interactuar con diversas fuentes de identidad:</p>

<table>
  <thead>
    <tr>
      <th>Tipo de Servidor</th>
      <th>Descripción</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Active Directory (AD)</strong></td>
      <td>Servicio de directorio de Microsoft que proporciona autenticación, autorización y políticas centralizadas, el foco de nuestro artículo.</td>
    </tr>
    <tr>
      <td><strong>Identity Management (IdM) en RHEL</strong></td>
      <td>Implementación de gestión de identidades integrada en RHEL basada en FreeIPA, ideal para entornos Linux puros o híbridos compatibles con AD.</td>
    </tr>
    <tr>
      <td><strong>Servidores genéricos LDAP o Kerberos</strong></td>
      <td>Sistemas de directorio o autenticación basados en estándares abiertos que proporcionan servicios de identidad sin la complejidad inherente de Active Directory o las características de IdM.</td>
    </tr>
  </tbody>
</table>

<h4 id="posix-id-mapping-vs-posix-attributes">POSIX ID Mapping vs. POSIX Attributes</h4>

<p>Cuando integramos Linux con Active Directory, nos enfrentamos a una diferencia fundamental: cómo manejan las identidades los usuarios.</p>

<ul>
  <li>Linux utiliza <strong>UID (User ID)</strong> y <strong>GID (Group ID)</strong>, siguiendo el estándar POSIX.</li>
  <li>Windows AD utiliza <strong>SID (Security ID)</strong>, un identificador único globalmente.</li>
</ul>

<p>Para que un usuario de Active Directory pueda acceder a un sistema Linux, necesitamos traducir o asignar esos identificadores de Windows (SID) a los de Linux (UID/GID).<br />
Aquí es donde SSSD ofrece dos opciones principales:</p>

<ol>
  <li><strong>POSIX ID Mapping</strong></li>
  <li><strong>POSIX Attributes</strong></li>
</ol>

<h5 id="posix-id-mapping-mapeo-automático">POSIX ID Mapping (mapeo automático)</h5>

<ul>
  <li>Esta es la opción predeterminada.</li>
  <li>En este modo, SSSD genera automáticamente los <strong>UID</strong> y <strong>GID</strong> a partir del <strong>SID</strong> de cada usuario de AD mediante un algoritmo interno.</li>
  <li>Así, no es necesario modificar nada dentro de Active Directory.</li>
</ul>

<h5 id="posix-attributes-atributos-posix-en-ad">POSIX Attributes (atributos POSIX en AD)</h5>

<ul>
  <li>En este modo, los <strong>UID</strong> y <strong>GID</strong> se definen directamente en Active Directory, utilizando los atributos POSIX estándar (como <code class="language-plaintext highlighter-rouge">uidNumber</code>, <code class="language-plaintext highlighter-rouge">gidNumber</code>, <code class="language-plaintext highlighter-rouge">unixHomeDirectory</code>, etc.).</li>
  <li>SSSD simplemente lee esos valores cuando el usuario inicia sesión.</li>
  <li>Requiere editar o extender el esquema de AD para incluir los atributos POSIX, y la configuración es más compleja.</li>
</ul>

<h2 id="demo-integrando-rhel-con-active-directory">¡Demo! Integrando RHEL con Active Directory</h2>

<p>En esta práctica, integraremos un sistema <strong>RHEL 10</strong> a un dominio de <strong>Active Directory 2019</strong> utilizando <strong>SSSD</strong> y el método de <strong>POSIX ID Mapping</strong>.</p>

<p>Utilizaremos un dominio ficticio para fines educativos: <code class="language-plaintext highlighter-rouge">umbrella.corp</code>.</p>

<p>El objetivo es permitir que los usuarios de Active Directory puedan autenticarse directamente en Linux con su nombre de usuario y contraseña de AD, sin necesidad de crear cuentas locales en RHEL.<br />
Gracias a SSSD y POSIX ID Mapping, RHEL asignará automáticamente los <strong>UID</strong> y <strong>GID</strong> a los usuarios de AD, garantizando una identidad única dentro del sistema Linux sin modificar Active Directory.</p>

<hr />

<h3 id="información-de-los-sistemas">Información de los Sistemas</h3>

<h4 id="rhel-100">RHEL 10.0</h4>

<table>
  <thead>
    <tr>
      <th>Campo</th>
      <th>Valor</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Hostname</strong></td>
      <td>leon</td>
    </tr>
    <tr>
      <td><strong>IP</strong></td>
      <td>192.168.6.4</td>
    </tr>
    <tr>
      <td><strong>Sistema Operativo</strong></td>
      <td>RHEL 10.0</td>
    </tr>
    <tr>
      <td><strong>Rol</strong></td>
      <td>Servidor Linux a integrar con Active Directory</td>
    </tr>
    <tr>
      <td><strong>Dominio</strong></td>
      <td>umbrella.corp</td>
    </tr>
    <tr>
      <td><strong>DNS Primario</strong></td>
      <td>192.168.6.7</td>
    </tr>
    <tr>
      <td><strong>Estado Integración AD</strong></td>
      <td>Pendiente</td>
    </tr>
    <tr>
      <td><strong>Comentarios</strong></td>
      <td>Usará SSSD y realmd para unir al dominio</td>
    </tr>
  </tbody>
</table>

<hr />

<h4 id="windows-server-2019-active-directory--dns">Windows Server 2019 (Active Directory / DNS)</h4>

<table>
  <thead>
    <tr>
      <th>Campo</th>
      <th>Valor</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Hostname</strong></td>
      <td>WIN-TURSKABH596</td>
    </tr>
    <tr>
      <td><strong>IP</strong></td>
      <td>192.168.6.7</td>
    </tr>
    <tr>
      <td><strong>Sistema Operativo</strong></td>
      <td>Windows Server 2019</td>
    </tr>
    <tr>
      <td><strong>Rol</strong></td>
      <td>Controlador de Dominio / DNS</td>
    </tr>
    <tr>
      <td><strong>Dominio</strong></td>
      <td>umbrella.corp</td>
    </tr>
    <tr>
      <td><strong>DNS Primario</strong></td>
      <td>192.168.6.7</td>
    </tr>
    <tr>
      <td><strong>Comentarios</strong></td>
      <td>Servidor principal del dominio, provee DNS interno</td>
    </tr>
  </tbody>
</table>

<hr />

<blockquote>
  <p><strong>Nota:</strong><br />
El controlador de dominio también funciona como servidor DNS del dominio.<br />
Esto es importante porque Active Directory depende del DNS para localizar controladores de dominio y otros servicios.<br />
RHEL apunta a este DNS para poder resolver nombres dentro del dominio y autenticar usuarios correctamente.</p>
</blockquote>

<hr />

<h3 id="requisitos-previos">Requisitos previos</h3>

<p>Antes de empezar, hay que asegurarse de que el entorno tiene:</p>

<ul>
  <li><strong>Conectividad de red</strong> Los puertos necesarios para la comunicación con AD deben estar abiertos.</li>
</ul>

<table>
  <thead>
    <tr>
      <th>Servicio</th>
      <th>Puerto</th>
      <th>Protocolo</th>
      <th>Notas</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>DNS</strong></td>
      <td>53</td>
      <td>UDP y TCP</td>
      <td>—</td>
    </tr>
    <tr>
      <td><strong>LDAP</strong></td>
      <td>389</td>
      <td>UDP y TCP</td>
      <td>—</td>
    </tr>
    <tr>
      <td><strong>LDAPS</strong></td>
      <td>636</td>
      <td>TCP</td>
      <td>Opcional</td>
    </tr>
    <tr>
      <td><strong>Samba</strong></td>
      <td>445</td>
      <td>UDP y TCP</td>
      <td>Para los Objetos de Directiva de Grupo (GPO)</td>
    </tr>
    <tr>
      <td><strong>Kerberos</strong></td>
      <td>88</td>
      <td>UDP y TCP</td>
      <td>—</td>
    </tr>
    <tr>
      <td><strong>Kerberos (kadmin)</strong></td>
      <td>464</td>
      <td>UDP y TCP</td>
      <td>Usado por <em>kadmin</em> para establecer y cambiar contraseñas</td>
    </tr>
    <tr>
      <td><strong>Catálogo Global LDAP</strong></td>
      <td>3268</td>
      <td>TCP</td>
      <td>Si se usa la opción <code class="language-plaintext highlighter-rouge">id_provider = ad</code></td>
    </tr>
    <tr>
      <td><strong>Catálogo Global LDAPS</strong></td>
      <td>3269</td>
      <td>TCP</td>
      <td>Opcional</td>
    </tr>
    <tr>
      <td><strong>NTP</strong></td>
      <td>123</td>
      <td>UDP</td>
      <td>Opcional</td>
    </tr>
    <tr>
      <td><strong>NTP</strong></td>
      <td>323</td>
      <td>UDP</td>
      <td>Opcional</td>
    </tr>
  </tbody>
</table>

<hr />

<ul>
  <li><strong>Configuración DNS</strong></li>
</ul>

<p>El servidor DNS de tu RHEL debe apuntar al controlador de dominio de Active Directory.<br />
Puedes verificarlo en <code class="language-plaintext highlighter-rouge">/etc/resolv.conf</code>.</p>

<p><img src="/assets/images/20251024/20251024-02.png" alt="Texto alternativo" />
<img src="/assets/images/20251024/20251024-03.png" alt="Texto alternativo" /></p>

<hr />

<ul>
  <li><strong>Sincronización de hora (NTP)</strong></li>
</ul>

<p>La hora del sistema RHEL debe estar sincronizada con el AD.<br />
Esto es crítico para el correcto funcionamiento de <strong>Kerberos</strong>.</p>

<p><img src="/assets/images/20251024/20251024-04.png" alt="Texto alternativo" /></p>

<hr />

<h3 id="empecemos-con-la-instalación">Empecemos con la instalación</h3>

<p>Para empezar, instalamos los paquetes esenciales para la integración con Active Directory y el funcionamiento de SSSD:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>dnf <span class="nb">install </span>samba-common-tools realmd oddjob oddjob-mkhomedir sssd adcli krb5-workstation
</code></pre></div></div>
<p><img src="/assets/images/20251024/20251024-05.png" alt="Texto alternativo" /></p>

<p>Una vez instalados los paquetes, podemos usar realm discover para verificar la existencia y obtener información sobre nuestro dominio de Active Directory</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>realm discover ad.example.com
</code></pre></div></div>

<p><img src="/assets/images/20251024/20251024-06.png" alt="Texto alternativo" /></p>

<p>Es normal que el configured salga como no antes de unirse al dominio.</p>

<p>Antes de unir RHEL al dominio, es necesario ajustar las políticas criptográficas para soportar algunas configuraciones de Active Directory más antiguas</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>update-crypto-policies <span class="nt">--set</span> DEFAULT:AD-SUPPORT-LEGACY
</code></pre></div></div>

<p><img src="/assets/images/20251024/20251024-07.png" alt="Texto alternativo" /></p>

<p>Se recomienda hacer un reboot para que se apliquen las politicas, es necessario reiniciar los servicios para que se aplique y con el reboot se inician todos de nuevo…</p>

<p>Esto permite que el sistema Linux utilice algoritmos y protocolos de cifrado compatibles con versiones de Active Directory que aún no soportan las políticas criptográficas más estrictas de RHEL 10 por defecto. Si no se aplica este ajuste, el intento de unir el dominio (realm join) puede fallar debido a incompatibilidades de cifrado o autenticación.</p>

<p>Ahora, el paso crucial, unir el sistema RHEL al dominio de Active Directory. El comando realm join no solo une el equipo, sino que también configura SSSD automáticamente con los parámetros adecuados. Te pedirá la contraseña de un usuario con permisos para unir equipos al dominio (por ejemplo, el usuario Administrator de AD).</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>realm <span class="nb">join </span>ad.example.com <span class="nt">-v</span> 
</code></pre></div></div>
<p><img src="/assets/images/20251024/20251024-08.png" alt="Texto alternativo" />
<img src="/assets/images/20251024/20251024-09.png" alt="Texto alternativo" /></p>

<p>Para comprobar que la integración ha sido exitosa y que los usuarios de Active Directory son reconocidos en RHEL, podemos usar el comando getent passwd con un usuario de AD.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>getent passwd administrator@ad.example.com
</code></pre></div></div>
<p><img src="/assets/images/20251024/20251024-10.png" alt="Texto alternativo" /></p>

<p>Ahora RHEL ja está integrado con Active Directory. Cualquier usuario de AD puede iniciar sesión en RHEL utilizando las credenciales de dominio</p>]]></content><author><name>Xavi Vico Marti</name></author><category term="RedHat" /><category term="ActiveDirectory" /><category term="RHEL" /><category term="ActiveDirectory" /><category term="SSSD" /><summary type="html"><![CDATA[Guía para integrar Red Hat Enterprise Linux 10.0 (RHEL 10) con Active Directory 2019, utilizando las herramientas SSSD y realmd]]></summary></entry><entry><title type="html">Red Hat Ansible Automation Platform 2.5: Guía de Instalación en RHEL 10 (Topología Growth Contenerizada)</title><link href="http://localhost:4000/automation/ansible/redhat/AAP-Guia-de-instalacion-2.5/" rel="alternate" type="text/html" title="Red Hat Ansible Automation Platform 2.5: Guía de Instalación en RHEL 10 (Topología Growth Contenerizada)" /><published>2025-10-01T00:00:00+02:00</published><updated>2025-10-01T00:00:00+02:00</updated><id>http://localhost:4000/automation/ansible/redhat/AAP-Guia-de%20instalacion-2.5</id><content type="html" xml:base="http://localhost:4000/automation/ansible/redhat/AAP-Guia-de-instalacion-2.5/"><![CDATA[<h2 id="red-hat-ansible-automation-platform-25-tu-guía-práctica-de-instalación-en-rhel-10-topología-growth-contenerizada">Red Hat Ansible Automation Platform 2.5: Tu Guía Práctica de Instalación en RHEL 10 (Topología Growth Contenerizada)</h2>

<h3 id="introducción">Introducción</h3>

<p>Esta guía sirve para ver el proceso de instalación de Red Hat Ansible Automation Platform (AAP) 2.5 en un entorno Red Hat Enterprise Linux (RHEL) 10. El objetivo es instalar AAP utilizando una topología “Growth” contenerizada, lo que significa que todos los componentes se instalarán en una única máquina virtual.</p>

<p>Esta configuración es perfecta para desarrolladores, para realizar pruebas o para pequeñas implementaciones donde estás comenzando a explorar el poder de la automatización con AAP. Además, lo mejor de esta topología es su flexibilidad, se podrá escalar a una arquitectura “Enterprise” más compleja, con alta disponibilidad y recursos distribuidos.</p>

<p>En este artículo, revisaremos los requisitos previos del sistema, la configuración esencial del entorno y los componentes clave de AAP, para tener una base sólida antes de empezar la instalación paso a paso.</p>

<h3 id="entendiendo-ansible-automation-platform-aap">Entendiendo Ansible Automation Platform (AAP)</h3>

<p>Antes de meternos de lleno en los detalles técnicos, es fundamental entender qué es exactamente Ansible Automation Platform y por qué se ha convertido en una herramienta tan valiosa.</p>

<p>Para situarnos mejor, vamos a entender conceptos:</p>

<ul>
  <li><strong>Ansible</strong>: el motor de automatización, la herramienta base que permite definir y ejecutar tareas en servidores y sistemas.</li>
  <li><strong>AWX</strong>: el proyecto open source que añade una interfaz gráfica y servicios básicos para gestionar Ansible de forma más cómoda.</li>
  <li><strong>AAP (Ansible Automation Platform)</strong>: la versión empresarial respaldada por Red Hat, que parte de AWX y lo expande con seguridad, soporte oficial y funcionalidades avanzadas para producción y grandes organizaciones.</li>
</ul>

<p>Imagina que tienes que realizar la misma tarea repetidamente en decenas, o incluso cientos, de servidores o sistemas. Suena aburrido y un palo…, Ansible nació para resolver ese problema, permite escribir instrucciones que tus sistemas pueden ejecutar por ti, como, por ejemplo: “instalar un servidor web Apache en todos mis servidores Linux”. Pues bien, AAP eleva esta capacidad a un nivel empresarial.</p>

<p>Piensa en AAP como la versión corporativa y robusta de AWX, el proyecto de código abierto y gratuito de Ansible. Mientras que AWX es fantástico para experimentar y familiarizarte con la interfaz y los conceptos de automatización, AAP añade capas críticas de seguridad, un soporte oficial de Red Hat inestimable, y herramientas avanzadas para gestionar entornos de gran escala con total confianza. No se limita a ejecutar comandos; AAP te ayuda a orquestar procesos complejos, centralizar inventarios y credenciales, y facilitar el trabajo en equipo a través de una interfaz gráfica intuitiva.</p>

<p>Muchas organizaciones empiezan con AWX para probar las aguas, pero cuando la automatización se convierte en un pilar fundamental de sus operaciones, necesitan una plataforma estable, respaldada y con funcionalidades avanzadas. Ahí es precisamente donde brilla AAP, incluyendo componentes como Automation Controller, Execution Environments, Automation Mesh, acceso a contenido validado, parches de seguridad y, crucialmente, el soporte oficial de Red Hat.</p>

<h3 id="topologías-y-métodos-de-instalación">Topologías y Métodos de Instalación</h3>

<p>Cuando instalas Ansible Automation Platform, la forma en que decides organizar tu infraestructura se conoce como “topología”. Esto define cómo se distribuyen los diferentes componentes de AAP en tus servidores y cómo se interconectan para asegurar un rendimiento óptimo y una operación estable.</p>

<p>Red Hat valida y recomienda ciertas topologías de despliegue para asegurar que la plataforma funcione de manera fiable y con soporte completo:</p>

<ul>
  <li><strong>Topología Enterprise</strong>: Diseñada para organizaciones grandes o entornos de producción críticos. Se enfoca en alta disponibilidad, máximo rendimiento y escalabilidad para manejar grandes volúmenes de usuarios y cargas de trabajo sin interrupciones.</li>
  <li><strong>Topología Growth</strong>: Ideal para organizaciones más pequeñas, entornos de desarrollo o con recursos limitados. Permite un despliegue más simple y económico al principio, con la flexibilidad de crecer y escalar a medida que tus necesidades evolucionan.</li>
</ul>

<p>Es importante recordar que, si bien puedes instalar AAP en otras configuraciones, Red Hat solo garantiza soporte completo para las topologías que ellos mismos han probado y publicado. Utilizar una topología validada asegura que tu plataforma sea estable y confiable a largo plazo.</p>

<p>Existen tres métodos principales para instalar y desplegar Ansible Automation Platform 2.5, dependiendo de tu infraestructura y tus preferencias de gestión. Para esta guía, nos centraremos en el método “Contenedores” y la topología “Growth”.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Método</th>
      <th style="text-align: left">Infraestructura</th>
      <th style="text-align: left">Descripción</th>
      <th style="text-align: left">Topologías probadas</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">RPM</td>
      <td style="text-align: left">Máquinas virtuales y servidores físicos</td>
      <td style="text-align: left">El instalador RPM despliega AAP en Red Hat Enterprise Linux utilizando paquetes RPM. El cliente gestiona el ciclo de vida del producto e infraestructura.</td>
      <td style="text-align: left">RPM growth topology, RPM enterprise topology</td>
    </tr>
    <tr>
      <td style="text-align: left">Contenedores</td>
      <td style="text-align: left">Máquinas virtuales y servidores físicos</td>
      <td style="text-align: left">El instalador basado en contenedores utiliza Podman para ejecutar AAP en contenedores sobre RHEL. El cliente gestiona el ciclo de vida del producto e infraestructura.</td>
      <td style="text-align: left">Container growth topology, Container enterprise topology</td>
    </tr>
    <tr>
      <td style="text-align: left">Operator</td>
      <td style="text-align: left">Red Hat OpenShift</td>
      <td style="text-align: left">El operador despliega AAP dentro de OpenShift usando Red Hat OpenShift Operators. El cliente gestiona el ciclo de vida del producto e infraestructura.</td>
      <td style="text-align: left">Operator growth topology, Operator enterprise topology</td>
    </tr>
  </tbody>
</table>

<h3 id="componentes">Componentes</h3>

<p>Para armar el “rompecabezas” de Ansible Automation Platform, es crucial conocer las piezas que lo componen. AAP no es solo una herramienta, sino un ecosistema de servicios interconectados que trabajan juntos para potenciar tu automatización.</p>

<p>Los componentes más importantes que debemos conocer, basándome en la documentación oficial de Red Hat:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Componente</th>
      <th style="text-align: left">Descripción</th>
      <th style="text-align: left">¿Por qué importa?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Platform Gateway</td>
      <td style="text-align: left">La puerta de entrada a AAP. Maneja autenticación, permisos y guarda un registro de cambios (activity stream).</td>
      <td style="text-align: left">Te logueas una sola vez y accedes a todo. Además, tienes trazabilidad de lo que pasa.</td>
    </tr>
    <tr>
      <td style="text-align: left">Automation Controller</td>
      <td style="text-align: left">El cerebro de la plataforma. Define, ejecuta y escala automatizaciones.</td>
      <td style="text-align: left">Permite orquestar playbooks desde lo simple hasta lo empresarial.</td>
    </tr>
    <tr>
      <td style="text-align: left">Automation Hub</td>
      <td style="text-align: left">El “mercado central” de colecciones certificadas por Red Hat y partners.</td>
      <td style="text-align: left">Usas contenido probado y soportado, sin reinventar la rueda.</td>
    </tr>
    <tr>
      <td style="text-align: left">Private Automation Hub</td>
      <td style="text-align: left">Tu propio hub privado y desconectado. Sincroniza contenido y guarda colecciones personalizadas.</td>
      <td style="text-align: left">Ideal para entornos on-premise o integrados con CI/CD.</td>
    </tr>
    <tr>
      <td style="text-align: left">High Availability Hub</td>
      <td style="text-align: left">Una versión redundante y escalable del hub con múltiples nodos.</td>
      <td style="text-align: left">Alta disponibilidad = menos caídas y más tranquilidad.</td>
    </tr>
    <tr>
      <td style="text-align: left">Event-Driven Ansible Controller</td>
      <td style="text-align: left">Automatización reactiva: escucha eventos y ejecuta acciones con rulebooks.</td>
      <td style="text-align: left">Aumenta la agilidad y automatiza decisiones en tiempo real.</td>
    </tr>
    <tr>
      <td style="text-align: left">Automation Mesh</td>
      <td style="text-align: left">Una red de nodos distribuida que reparte la carga de trabajo.</td>
      <td style="text-align: left">Escalabilidad, resiliencia y flexibilidad en entornos grandes o dispersos.</td>
    </tr>
    <tr>
      <td style="text-align: left">Execution Environments</td>
      <td style="text-align: left">Contenedores donde se ejecutan los playbooks. Incluyen motor + módulos.</td>
      <td style="text-align: left">Portabilidad y consistencia: “si funciona aquí, funciona en todos lados”.</td>
    </tr>
    <tr>
      <td style="text-align: left">Ansible Galaxy</td>
      <td style="text-align: left">Comunidad para compartir roles y colecciones.</td>
      <td style="text-align: left">Reutilizas contenido y aceleras tus proyectos.</td>
    </tr>
    <tr>
      <td style="text-align: left">Content Navigator</td>
      <td style="text-align: left">Interfaz de texto (TUI) y CLI principal para construir y ejecutar automatizaciones.</td>
      <td style="text-align: left">Tu navaja suiza en la terminal, base de futuros IDEs.</td>
    </tr>
    <tr>
      <td style="text-align: left">PostgreSQL</td>
      <td style="text-align: left">Base de datos relacional donde se guarda todo: inventarios, credenciales, historial.</td>
      <td style="text-align: left">La memoria de la plataforma.</td>
    </tr>
  </tbody>
</table>

<h3 id="detalles-técnicos">Detalles Técnicos</h3>

<p>Esta sección se enfoca en los requisitos validados por Red Hat para una instalación “Growth” contenerizada. Aquí muestro el diseño y las especificaciones para desplegar AAP en una única máquina virtual, de forma clara y sencilla.</p>

<h4 id="virtual-machine-requirements">Virtual machine requirements</h4>

<p>Estos son los requisitos mínimos de hardware para tu VM de RHEL 10 en una topología “Growth”:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Requirement</th>
      <th style="text-align: left">Minimum requirement</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">RAM</td>
      <td style="text-align: left">16 GB</td>
    </tr>
    <tr>
      <td style="text-align: left">CPUs</td>
      <td style="text-align: left">4</td>
    </tr>
    <tr>
      <td style="text-align: left">Local disk</td>
      <td style="text-align: left">Total available disk space: 60 GB<br />Installation directory: 15 GB (if on a dedicated partition)<br />/var/tmp for online installations: 1 GB<br />/var/tmp for offline or bundled installations: 3 GB<br />Temporary directory (defaults to /tmp) for offline or bundled installations: 10GB</td>
    </tr>
    <tr>
      <td style="text-align: left">Disk IOPS</td>
      <td style="text-align: left">3000</td>
    </tr>
  </tbody>
</table>

<h4 id="system-configuration">System configuration</h4>

<p>Estos son los aspectos clave que tu sistema RHEL 10 debe cumplir. Atención a la suscripción, ya que es un paso que a menudo se pasa por alto y puede causar problemas:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Tipo</th>
      <th style="text-align: left">Descripción</th>
      <th style="text-align: left">Notas</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Suscripción</td>
      <td style="text-align: left">Suscripción válida de Red Hat Ansible Automation Platform<br />Suscripción válida de Red Hat Enterprise Linux (para poder usar los repositorios BaseOS y AppStream)</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">Sistema operativo</td>
      <td style="text-align: left">Red Hat Enterprise Linux 9.2 o versiones posteriores de Red Hat Enterprise Linux 9.<br />Red Hat Enterprise Linux 10 o versiones posteriores de Red Hat Enterprise Linux 10.</td>
      <td style="text-align: left">—</td>
    </tr>
    <tr>
      <td style="text-align: left">Arquitectura de CPU</td>
      <td style="text-align: left">x86_64, AArch64, s390x (IBM Z), ppc64le (IBM Power)</td>
      <td style="text-align: left">—</td>
    </tr>
    <tr>
      <td style="text-align: left">ansible-core</td>
      <td style="text-align: left">RHEL 9: el programa de instalación usa <code class="language-plaintext highlighter-rouge">ansible-core</code> 2.14; la operación de Ansible Automation Platform usa <code class="language-plaintext highlighter-rouge">ansible-core</code> 2.16.<br />RHEL 10: el programa de instalación y la operación de Ansible Automation Platform usan <code class="language-plaintext highlighter-rouge">ansible-core</code> 2.16.</td>
      <td style="text-align: left">El programa de instalación utiliza el paquete <code class="language-plaintext highlighter-rouge">ansible-core</code> del repositorio AppStream de RHEL. Ansible Automation Platform incluye <code class="language-plaintext highlighter-rouge">ansible-core</code> 2.16 para su operación, por lo que no es necesario instalarlo manualmente.</td>
    </tr>
    <tr>
      <td style="text-align: left">Navegador</td>
      <td style="text-align: left">Una versión actualmente soportada de Mozilla Firefox o Google Chrome</td>
      <td style="text-align: left">—</td>
    </tr>
    <tr>
      <td style="text-align: left">Base de datos</td>
      <td style="text-align: left">PostgreSQL 15</td>
      <td style="text-align: left">Las bases de datos externas (soporte por el cliente) requieren soporte ICU.</td>
    </tr>
  </tbody>
</table>

<h4 id="network-ports-and-protocols">Network ports and protocols</h4>

<p>A continuación, se listan los puertos de red y protocolos que AAP utiliza para la comunicación entre sus componentes. Es crucial que estos puertos estén abiertos en el firewall para asegurar la correcta operación de la plataforma:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Port number</th>
      <th style="text-align: left">Protocol</th>
      <th style="text-align: left">Service</th>
      <th style="text-align: left">Source</th>
      <th style="text-align: left">Destination</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">80/443</td>
      <td style="text-align: left">TCP</td>
      <td style="text-align: left">HTTP/HTTPS</td>
      <td style="text-align: left">Event-Driven Ansible</td>
      <td style="text-align: left">Automation hub</td>
    </tr>
    <tr>
      <td style="text-align: left">80/443</td>
      <td style="text-align: left">TCP</td>
      <td style="text-align: left">HTTP/HTTPS</td>
      <td style="text-align: left">Event-Driven Ansible</td>
      <td style="text-align: left">Automation controller</td>
    </tr>
    <tr>
      <td style="text-align: left">80/443</td>
      <td style="text-align: left">TCP</td>
      <td style="text-align: left">HTTP/HTTPS</td>
      <td style="text-align: left">Automation controller</td>
      <td style="text-align: left">Automation hub</td>
    </tr>
    <tr>
      <td style="text-align: left">80/443</td>
      <td style="text-align: left">TCP</td>
      <td style="text-align: left">HTTP/HTTPS</td>
      <td style="text-align: left">Platform gateway</td>
      <td style="text-align: left">Automation controller</td>
    </tr>
    <tr>
      <td style="text-align: left">80/443</td>
      <td style="text-align: left">TCP</td>
      <td style="text-align: left">HTTP/HTTPS</td>
      <td style="text-align: left">Platform gateway</td>
      <td style="text-align: left">Automation hub</td>
    </tr>
    <tr>
      <td style="text-align: left">80/443</td>
      <td style="text-align: left">TCP</td>
      <td style="text-align: left">HTTP/HTTPS</td>
      <td style="text-align: left">Platform gateway</td>
      <td style="text-align: left">Event-Driven Ansible</td>
    </tr>
    <tr>
      <td style="text-align: left">5432</td>
      <td style="text-align: left">TCP</td>
      <td style="text-align: left">PostgreSQL</td>
      <td style="text-align: left">Event-Driven Ansible</td>
      <td style="text-align: left">External database</td>
    </tr>
    <tr>
      <td style="text-align: left">5432</td>
      <td style="text-align: left">TCP</td>
      <td style="text-align: left">PostgreSQL</td>
      <td style="text-align: left">Platform gateway</td>
      <td style="text-align: left">External database</td>
    </tr>
    <tr>
      <td style="text-align: left">5432</td>
      <td style="text-align: left">TCP</td>
      <td style="text-align: left">PostgreSQL</td>
      <td style="text-align: left">Automation hub</td>
      <td style="text-align: left">External database</td>
    </tr>
    <tr>
      <td style="text-align: left">5432</td>
      <td style="text-align: left">TCP</td>
      <td style="text-align: left">PostgreSQL</td>
      <td style="text-align: left">Automation controller</td>
      <td style="text-align: left">External database</td>
    </tr>
    <tr>
      <td style="text-align: left">6379</td>
      <td style="text-align: left">TCP</td>
      <td style="text-align: left">Redis</td>
      <td style="text-align: left">Event-Driven Ansible</td>
      <td style="text-align: left">Redis container</td>
    </tr>
    <tr>
      <td style="text-align: left">6379</td>
      <td style="text-align: left">TCP</td>
      <td style="text-align: left">Redis</td>
      <td style="text-align: left">Platform gateway</td>
      <td style="text-align: left">Redis container</td>
    </tr>
    <tr>
      <td style="text-align: left">8443</td>
      <td style="text-align: left">TCP</td>
      <td style="text-align: left">HTTPS</td>
      <td style="text-align: left">Platform gateway</td>
      <td style="text-align: left">Platform gateway</td>
    </tr>
    <tr>
      <td style="text-align: left">27199</td>
      <td style="text-align: left">TCP</td>
      <td style="text-align: left">Receptor</td>
      <td style="text-align: left">Automation controller</td>
      <td style="text-align: left">Execution container</td>
    </tr>
  </tbody>
</table>

<h3 id="practica---instalación-de-ansible-automation-platform">PRACTICA - Instalación de Ansible Automation Platform</h3>

<p>La instalación de Ansible Automation Platform requiere una serie de pasos preparatorios para asegurar un despliegue sin problemas. Nos centraremos en una instalación “Growth” contenerizada en RHEL 10.</p>

<h4 id="preparación-del-sistema-operativo">Preparación del Sistema Operativo</h4>

<p><strong>Configuración del Usuario y Privilegios Sudo</strong></p>

<p>Para la instalación, el usuario que ejecuta el instalador debe tener permisos para elevar privilegios a root sin necesidad de introducir una contraseña. Esto es fundamental, ya que muchos pasos del proceso requieren modificar servicios, paquetes y configuraciones críticas del sistema.</p>

<p>Para configurar esto, editamos el archivo <code class="language-plaintext highlighter-rouge">sudoers</code> (lo recomendado es crear un archivo nuevo en /etc/sudoers.d/user, esto es un ejemplo) y añadir una línea similar a la siguiente, sustituyendo <code class="language-plaintext highlighter-rouge">user</code> por el nombre de tu usuario:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user <span class="nv">ALL</span><span class="o">=(</span>ALL<span class="o">)</span> NOPASSWD: ALL
</code></pre></div></div>
<p><img src="/assets/images/AAPInstallguide/AAP01.png" alt="Texto alternativo" /></p>

<p>Esto permite a <code class="language-plaintext highlighter-rouge">user</code> ejecutar comandos como <code class="language-plaintext highlighter-rouge">root</code> con <code class="language-plaintext highlighter-rouge">sudo</code> sin pedir contraseña.</p>

<p><strong>Verificación del Nombre de Host (FQDN)</strong></p>

<p>Es crucial que el nombre de host del servidor esté configurado como un Nombre de Dominio Completamente Cualificado (FQDN). Esto asegura una comunicación adecuada entre los servicios de AAP.</p>

<p>Podemos verificarlo con el siguiente comando:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">hostname</span> <span class="nt">-f</span>
</code></pre></div></div>
<p><img src="/assets/images/AAPInstallguide/AAP02.png" alt="Texto alternativo" /></p>

<p>Si no devuelve un FQDN, debemos configurarlo en nuestro sistema RHEL.</p>

<p><strong>Gestión de Suscripciones y Repositorios</strong></p>

<p>Para acceder a los paquetes y contenedores de Red Hat, el servidor RHEL debe estar correctamente suscrito y los repositorios necesarios deben estar habilitados.</p>

<p>Nos aseguramos de que el sistema está suscrito a Red Hat y que tiene acceso a los repositorios <code class="language-plaintext highlighter-rouge">BaseOS</code> y <code class="language-plaintext highlighter-rouge">AppStream</code>. Podemos comprobar el estado de la suscripción con:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>subscription-manager status
</code></pre></div></div>
<p><img src="/assets/images/AAPInstallguide/AAP03.png" alt="Texto alternativo" /></p>

<p>Si no está suscrito, podemos registrarlo con:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>subscription-manager register
</code></pre></div></div>

<p>Es necesario que los repositorios de <code class="language-plaintext highlighter-rouge">AppStream</code> y <code class="language-plaintext highlighter-rouge">BaseOS</code> estén habilitados, para ello verificamos que los tenemos activos.
Aquí tenemos una imagen que muestra cómo verificar los repositorios activos:</p>

<p><img src="/assets/images/AAPInstallguide/AAP04.png" alt="Texto alternativo" /></p>

<p>Siguiente paso, instalamos el paquete <code class="language-plaintext highlighter-rouge">ansible-core</code>, que el instalador de AAP utilizará.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>dnf <span class="nb">install </span>ansible-core <span class="nt">-y</span>
</code></pre></div></div>
<p><img src="/assets/images/AAPInstallguide/AAP05.png" alt="Texto alternativo" /></p>

<p>Y opcionalmente podemos instalar los paquetes <code class="language-plaintext highlighter-rouge">wget</code>, <code class="language-plaintext highlighter-rouge">git-core</code>, <code class="language-plaintext highlighter-rouge">rsync</code> y <code class="language-plaintext highlighter-rouge">vim</code> que nos pueden ser útiles durante la instalación:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>dnf <span class="nb">install </span>wget git-core rsync vim <span class="nt">-y</span>
</code></pre></div></div>

<h4 id="descarga-del-instalador-de-ansible-automation-platform">Descarga del Instalador de Ansible Automation Platform</h4>

<p>Visitamos el portal de descargas de Ansible Automation Platform. Desde allí es posible obtener las versiones más recientes del instalador.</p>

<p>Existen dos modalidades principales de instalación:</p>

<ul>
  <li><strong>Instalación Online</strong>: Selecciona la opción “Ansible Automation Platform 2.5 Containerized Setup”. En este caso, durante el proceso de instalación, el instalador descargará los contenedores necesarios directamente desde los repositorios de Red Hat.</li>
  <li><strong>Instalación Offline (paquete completo)</strong>: Selecciona la opción “Ansible Automation Platform 2.5 Containerized Setup Bundle”. Este paquete incluye todos los artefactos requeridos para entornos aislados de Internet o con restricciones de red.</li>
</ul>

<p>Nosotros para esta guía elegiremos la online, una vez elegida la modalidad, descargamos el archivo <code class="language-plaintext highlighter-rouge">.tar.gz</code> correspondiente a la versión y arquitectura del sistema.</p>

<p>Aquí tenemos una imagen que ilustra la descarga desde el portal:</p>

<p><img src="/assets/images/AAPInstallguide/AAP06.png" alt="Texto alternativo" /></p>

<p>Los archivos descargados deben copiarse a la máquina donde se realizará la instalación. Esto suele hacerse desde la estación de administración hacia el servidor RHEL destino.</p>

<p>La forma más segura de realizar esta transferencia es mediante SCP (Secure Copy Protocol).</p>

<p>En el servidor RHEL, tendremos que definir un directorio que servirá como punto de instalación.</p>

<p>Requisito importante: debemos asegurarnos de contar con al menos 15 GB de espacio libre en el directorio seleccionado, ya que la instalación inicial genera múltiples contenedores y datos temporales.</p>

<p>En este caso utilizaremos <code class="language-plaintext highlighter-rouge">/home/user/demos</code> para descomprimir el archivo tar:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir</span> <span class="nt">-p</span> /home/user/demos
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">df</span> <span class="nt">-h</span> /home/user/demos
</code></pre></div></div>
<p><img src="/assets/images/AAPInstallguide/AAP07.png" alt="Texto alternativo" /></p>

<p>Con los archivos ya presentes en el servidor, vamos a descomprimir el instalador en el directorio <code class="language-plaintext highlighter-rouge">demos</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">tar</span> <span class="nt">-xvzf</span> ansible-automation-platform-setup-2.5-containerized-tar.gz <span class="nt">-C</span> /home/user/demos
</code></pre></div></div>
<p><img src="/assets/images/AAPInstallguide/AAP08.png" alt="Texto alternativo" /></p>

<p>Al finalizar, se creará un directorio con todos los archivos y scripts necesarios para continuar con el despliegue de la plataforma.</p>

<h4 id="configuración-del-archivo-de-inventario">Configuración del Archivo de Inventario</h4>

<p><img src="/assets/images/AAPInstallguide/AAP09.png" alt="Texto alternativo" /></p>

<p>Cuando instalamos Ansible Automation Platform (AAP), todo gira en torno a un archivo llamado <code class="language-plaintext highlighter-rouge">inventory</code>. Este archivo es como el “mapa” que le dice al instalador qué componentes debe desplegar, en qué servidores y con qué configuraciones.</p>

<p>Sin este archivo, el instalador no sabe qué hacer, así que aquí te explico cómo funciona y cómo puedes adaptarlo a tu entorno.</p>

<p>Dentro del paquete de instalación que hemos descargado vienen ejemplos de inventario:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">inventory</code>: pensado para instalaciones enterprise (distribuidas, con varios nodos).</li>
  <li><code class="language-plaintext highlighter-rouge">inventory-growth</code>: pensado para instalaciones all-in-one (todo en un mismo servidor).</li>
</ul>

<p><img src="/assets/images/AAPInstallguide/AAP10.png" alt="Texto alternativo" /></p>

<p>La topología que queremos implementar es la growth, vamos a modificar el <code class="language-plaintext highlighter-rouge">inventory-growth</code> para que se ajuste a nuestra configuración.</p>

<p>Para ello abrimos el archivo y añadimos nuestro <code class="language-plaintext highlighter-rouge">fqdn</code> y credenciales de Red Hat en los campos necesarios. El archivo se verá similar a este:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># This is the AAP installer inventory file intended for the Container growth deployment topology.  </span>
<span class="c1"># This inventory file expects to be run from the host where AAP will be installed.  </span>
<span class="c1"># Please consult the Ansible Automation Platform product documentation about this topology's tested hardware configuration.  </span>
<span class="c1"># https://docs.redhat.com/en/documentation/red_hat_ansible_automation_platform/2.5/html/tested_deployment_models/container-topologies  </span>
<span class="c1">#  </span>
<span class="c1"># Please consult the docs if you're unsure what to add  </span>
<span class="c1"># For all optional variables please consult the included README.md  </span>
<span class="c1"># or the Ansible Automation Platform documentation:  </span>
<span class="c1"># https://docs.redhat.com/en/documentation/red_hat_ansible_automation_platform/2.5/html/containerized_installation  </span>
 
<span class="c1"># This section is for your AAP Gateway host(s)  </span>
<span class="c1"># -----------------------------------------------------  </span>
<span class="pi">[</span><span class="nv">automationgateway</span><span class="pi">]</span>  
<span class="s">your.fqdn.here</span>  
 
<span class="c1"># This section is for your AAP Controller host(s)  </span>
<span class="c1"># -----------------------------------------------------  </span>
<span class="pi">[</span><span class="nv">automationcontroller</span><span class="pi">]</span>  
<span class="s">your.fqdn.here</span>  
 
<span class="c1"># This section is for your AAP Automation Hub host(s)  </span>
<span class="c1"># -----------------------------------------------------  </span>
<span class="pi">[</span><span class="nv">automationhub</span><span class="pi">]</span>  
<span class="s">your.fqdn.here</span>  
 
<span class="c1"># This section is for your AAP EDA Controller host(s)  </span>
<span class="c1"># -----------------------------------------------------  </span>
<span class="pi">[</span><span class="nv">automationeda</span><span class="pi">]</span>  
<span class="s">your.fqdn.here</span>  
 
<span class="c1"># This section is for the AAP database  </span>
<span class="c1"># -----------------------------------------------------  </span>
<span class="pi">[</span><span class="nv">database</span><span class="pi">]</span>  
<span class="s">your.fqdn.here</span>  
 
<span class="pi">[</span><span class="nv">all</span><span class="pi">:</span><span class="nv">vars</span><span class="pi">]</span>  
<span class="c1"># Ansible  </span>
<span class="s">ansible_connection=local</span>  
 
<span class="c1"># Common variables  </span>
<span class="c1"># https://docs.redhat.com/en/documentation/red_hat_ansible_automation_platform/2.5/html/containerized_installation/appendix-inventory-files-vars#ref-general-inventory-variables  </span>
<span class="c1"># -----------------------------------------------------  </span>
<span class="s">postgresql_admin_username=postgres</span>  
<span class="s">postgresql_admin_password=your_postgresql_admin_password</span>  
 
<span class="s">registry_username=your_rhn_username</span>  
<span class="s">registry_password=your_rhn_password</span>  
 
<span class="s">redis_mode=standalone</span>  
 
<span class="c1"># AAP Gateway  </span>
<span class="c1"># https://docs.redhat.com/en/documentation/red_hat_ansible_automation_platform/2.5/html/containerized_installation/appendix-inventory-files-vars#ref-gateway-variables  </span>
<span class="c1"># -----------------------------------------------------  </span>
<span class="s">gateway_admin_password=your_gateway_admin_password</span>  
<span class="s">gateway_pg_host=your.fqdn.here</span>  
<span class="s">gateway_pg_password=your_gateway_pg_password</span>  
 
<span class="c1"># AAP Controller  </span>
<span class="c1"># https://docs.redhat.com/en/documentation/red_hat_ansible_automation_platform/2.5/html/containerized_installation/appendix-inventory-files-vars#ref-controller-variables  </span>
<span class="c1"># -----------------------------------------------------  </span>
<span class="s">controller_admin_password=your_controller_admin_password</span>  
<span class="s">controller_pg_host=your.fqdn.here</span>  
<span class="s">controller_pg_password=your_controller_pg_password</span>  
<span class="s">controller_percent_memory_capacity=0.5</span>  
 
<span class="c1"># AAP Automation Hub  </span>
<span class="c1"># https://docs.redhat.com/en/documentation/red_hat_ansible_automation_platform/2.5/html/containerized_installation/appendix-inventory-files-vars#ref-hub-variables  </span>
<span class="c1"># -----------------------------------------------------  </span>
<span class="s">hub_admin_password=your_hub_admin_password</span>  
<span class="s">hub_pg_host=your.fqdn.here</span>  
<span class="s">hub_pg_password=your_hub_pg_password</span>  
<span class="s">hub_seed_collections=false</span>  
 
<span class="c1"># AAP EDA Controller  </span>
<span class="c1"># https://docs.redhat.com/en/documentation/red_hat_ansible_automation_platform/2.5/html/containerized_installation/appendix-inventory-files-vars#event-driven-ansible-controller  </span>
<span class="c1"># -----------------------------------------------------  </span>
<span class="s">eda_admin_password=your_eda_admin_password</span>  
<span class="s">eda_pg_host=your.fqdn.here</span>  
<span class="s">eda_pg_password=your_eda_pg_password</span> 
</code></pre></div></div>

<p>Sustituimos <code class="language-plaintext highlighter-rouge">your.fqdn.here</code> por el <code class="language-plaintext highlighter-rouge">fqdn</code> de nuestra instancia donde instalaremos el Ansible Automation Platform.</p>

<p>Modificamos el <code class="language-plaintext highlighter-rouge">&lt;set your own&gt;</code> por las contraseñas que queramos para nuestro usuario admin en cada componente que se indica en el inventario.</p>

<p>Y en los campos <code class="language-plaintext highlighter-rouge">registry_username=your_rhn_username</code> y <code class="language-plaintext highlighter-rouge">registry_password=your_rhn_password</code> indicamos nuestro usuario y contraseña de la cuenta de Red Hat.</p>

<p>Una vez lo tenemos todo listo podemos lanzar el instalador y indicar el archivo de inventario correspondiente (opción <code class="language-plaintext highlighter-rouge">-i</code>). Nos tenemos que assegurar de estar en el directorio donde descomprimimos el instalador (e.g., <code class="language-plaintext highlighter-rouge">/home/user/demos/ansible-automation-platform-containerized-setup-2.5-19</code>).</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> /home/user/demos/ansible-automation-platform-containerized-setup-2.5-19
ansible-playbook <span class="nt">-i</span> inventory-growth ansible.containerized_installer.install
</code></pre></div></div>
<p><img src="/assets/images/AAPInstallguide/AAP11.png" alt="Texto alternativo" />
<img src="/assets/images/AAPInstallguide/AAP12.png" alt="Texto alternativo" /></p>

<p>Cuando finalice la instalación de Ansible Automation Platform (AAP), el siguiente paso es comprobar que la interfaz web esté disponible.</p>

<p>De manera predeterminada, podemos acceder escribiendo en el navegador:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://&lt;gateway_node&gt;:443
</code></pre></div></div>

<p>Aquí reemplazar <code class="language-plaintext highlighter-rouge">&lt;gateway_node&gt;</code> por el nombre o la dirección IP del servidor donde desplegamos el Automation Gateway.</p>

<p>Para entrar al panel, utilizar el usuario admin (<code class="language-plaintext highlighter-rouge">gateway_admin_username</code>) y la contraseña que definiste en la instalación (<code class="language-plaintext highlighter-rouge">gateway_admin_password</code>).</p>

<p>Aquí tenemos una captura de pantalla de la pantalla de inicio de sesión de AAP:
<img src="/assets/images/AAPInstallguide/AAP13.png" alt="Texto alternativo" /></p>

<p>Para habilitar el soporte completo y recibir actualizaciones, debemos activar la suscripción de Ansible Automation Platform. Dentro de la interfaz web, nos dirigimos a la sección de administración de suscripciones e introducimos nuestras credenciales de acceso de Red Hat (Client ID y Client Secret).</p>

<p><img src="/assets/images/AAPInstallguide/AAP14.png" alt="Texto alternativo" /></p>

<p>Finalmente, ya accedemos, ahora podemos empezar a explorar todas las capacidades de automatización que ofrece Ansible Automation Platform.</p>

<p><img src="/assets/images/AAPInstallguide/AAP15.png" alt="Texto alternativo" /></p>

<p>Mi idea con este artículo era desmitificar el proceso, compartir esa “receta” que a mí me ha funcionado bien para arrancar rápido con una topología “Growth”. Podemos pensar en ella como un campo de pruebas personal, donde podemos cacharrear, aprender y, lo más importante, empezar a ver lo que ofrece AAP sin el estrés de una configuración gigante y con una gran flexibilidad para crecer cuando nosotros queramos.</p>]]></content><author><name>Xavi Vico Marti</name></author><category term="Automation" /><category term="Ansible" /><category term="RedHat" /><category term="AAP" /><category term="AnsibleAutomationPlatform" /><category term="RHEL" /><category term="InstallationGuide" /><category term="Containerized" /><summary type="html"><![CDATA[Instalación de Red Hat Ansible Automation Platform 2.5 en RHEL 10. Guía para configurar una topología 'Growth' contenerizada, ideal para desarrollo y pruebas.]]></summary></entry><entry><title type="html">Seguridad Empresarial con Red Hat: Más Allá del Código Abierto</title><link href="http://localhost:4000/seguridad/red%20hat/open%20source/Seguridad-empresarial-con-red-hat/" rel="alternate" type="text/html" title="Seguridad Empresarial con Red Hat: Más Allá del Código Abierto" /><published>2025-09-15T00:00:00+02:00</published><updated>2025-09-15T00:00:00+02:00</updated><id>http://localhost:4000/seguridad/red%20hat/open%20source/Seguridad-empresarial-con-red-hat</id><content type="html" xml:base="http://localhost:4000/seguridad/red%20hat/open%20source/Seguridad-empresarial-con-red-hat/"><![CDATA[<h2 id="el-paradigma-de-la-seguridad-en-el-open-source">El Paradigma de la Seguridad en el Open Source</h2>

<p>El software de código abierto se ha convertido en una pieza clave para impulsar la innovación tecnológica. Su esencia está en la colaboración y la transparencia, lo que ha permitido avances extraordinarios, pero aquí es donde aparece lo que podríamos llamar el dilema del código abierto. Aunque este modelo colaborativo es su mayor fortaleza, también plantea desafíos cuando se trata de adoptarlo a nivel empresarial. No es el código en sí el problema, sino cómo las organizaciones entienden y, sobre todo, cómo gestionan su seguridad y los riesgos asociados.</p>

<p>El panorama de las vulnerabilidades ha cambiado radicalmente en las últimas décadas. Cuando nació el programa Common Vulnerabilities and Exposures (CVE) hace 25 años, se registraron 894 vulnerabilidades de seguridad en su primer año, estamos hablando de 1999. En 2024, esa cifra superó las 40,000. Este crecimiento exponencial ha dejado obsoleta la vieja estrategia de ‘parchearlo todo’, ya no es viable ni inteligente tratar todas las vulnerabilidades por igual. No todos los fallos representan el mismo nivel de riesgo, y centrarse en corregirlos todos sin priorizar ignora un punto clave, si realmente están siendo explotados o no. De hecho, los datos muestran que históricamente menos del 0.5% de las vulnerabilidades llegan a ser explotadas activamente.</p>

<p><img src="/assets/images/SERH1.png" alt="Texto alternativo" /></p>

<p>Aquí es donde la transparencia del código abierto puede jugar en contra, al ser públicos por naturaleza, los proyectos open source tienden a reportar y documentar una gran cantidad de fallos, incluso los de impacto bajo o moderado, en cambio, muchos proveedores de software propietario no revelan este tipo de vulnerabilidades menores, lo que crea una ilusión de mayor seguridad y un panorama de riesgo mucho más opaco.</p>

<p>Esto da lugar a un doble estándar, las políticas que exigen “Zero Known Vulnerabilities” terminan castigando al código abierto por ser más transparente, en lugar de enfocarse en lo que realmente importa, el riesgo real. Red Hat Product Security Risk Report 2024 lo deja claro. Aunque en 2024 aumentó notablemente el número de CVEs asignados a productos de Red Hat en parte porque el kernel de Linux empezó a funcionar como autoridad oficial para registrar fallos (CNA), el riesgo real detrás de esos números no cambió mucho, la mayoría de esas nuevas vulnerabilidades eran de bajo o moderado impacto, lo que refuerza una idea clave, necesitamos evaluar el riesgo con criterio, no simplemente contar vulnerabilidades.</p>

<p>El caso de XZ Backdoor, también abordado en el informe, fue una verdadera llamada de atención a nivel global sobre lo sofisticados que se han vuelto los ataques a la cadena de suministro de software (SSCA). Un atacante logró infiltrarse durante casi dos años, ganándose la confianza de la comunidad, hasta que finalmente introdujo código malicioso con el potencial de comprometer una enorme cantidad de sistemas.</p>

<p>Este incidente puso en evidencia lo crítica que es la seguridad en la cadena de suministro. Pero también dejó algo muy claro, el modelo de código abierto tiene una fortaleza única, gracias a la transparencia del código, la comunidad detectó y reaccionó rápidamente de forma colaborativa, esa respuesta ágil y abierta fue clave para contener la amenaza a tiempo.</p>

<p>Red Hat no se limita a usar software de código abierto, participa activamente en su evolución, lo mantiene y lo fortalece, es un actor clave dentro del ecosistema, con un conocimiento profundo de las normativas globales y una visión anticipada de las amenazas emergentes, Red Hat incorpora la seguridad desde el inicio y a lo largo de todo su ciclo de desarrollo de software (RHSDLC).</p>

<p>Además, su rol como participante raíz del programa CVE y CNA lo coloca en una posición única, no solo identifica y evalúa vulnerabilidades, sino que ofrece a sus clientes soluciones concretas y respaldadas por un nivel de experiencia difícil de igualar.</p>

<p>Las organizaciones necesitan más que solo software de código abierto, necesitan una plataforma open source reforzada, gestionada y segura por diseño, aquí es donde los productos de Red Hat marcan la diferencia.</p>

<h2 id="red-hat-enterprise-linux-rhel-la-base-reforzada">Red Hat Enterprise Linux (RHEL): La Base Reforzada</h2>

<p>Toda estrategia de seguridad empresarial robusta debe construirse sobre una base sólida, en el ecosistema de Red Hat, esa base es Red Hat Enterprise Linux (RHEL), no todas las distribuciones de Linux son iguales en lo que a seguridad se refiere. RHEL se distingue por un enfoque proactivo que abarca desde el cumplimiento de normativas globales y el endurecimiento del sistema hasta la preparación para amenazas emergentes, a continuación, exploramos algunas de las capas de defensa fundamentales integradas en RHEL.</p>

<h3 id="selinux-control-de-acceso-obligatorio-por-defecto">SELinux: Control de Acceso Obligatorio por Defecto</h3>
<p>La seguridad empresarial no consiste únicamente en cerrar puertos y aplicar parches, es una estrategia continua que debe abarcar el control de acceso, la integridad del software, la detección de intrusiones y la gestión proactiva de vulnerabilidades.</p>

<p>La primera línea de defensa es controlar estrictamente quién puede acceder a qué recursos y qué software puede ejecutarse, y no se puede hablar de seguridad en RHEL sin mencionar a SELinux (Security-Enhanced Linux), una herramienta de seguridad avanzada que viene activada por defecto en sistemas RHEL.</p>

<p>Aunque SELinux puede parecer una fuente de complicaciones especialmente cuando impide que aplicaciones personalizadas funcionen o bloquea el acceso a ciertas rutas o puertos, en realidad está haciendo su trabajo, aplicar un modelo de Control de Acceso Obligatorio (MAC). A diferencia del enfoque tradicional basado en permisos de archivos (DAC), SELinux define políticas estrictas y altamente granulares que controlan el comportamiento de usuarios, servicios y procesos. Utiliza etiquetas y tipos para decidir qué acciones están permitidas en archivos, carpetas y puertos, y cuáles no.</p>

<p>Tomemos el servicio web httpd como ejemplo práctico.</p>

<p>Por defecto:</p>

<ul>
  <li>El proceso httpd se ejecuta con el tipo SELinux httpd_t</li>
</ul>

<p><img src="/assets/images/SERH2.png" alt="Texto alternativo" /></p>

<ul>
  <li>El contenido en /var/www/html/ tiene la etiqueta httpd_sys_content_t, lo que permite que el servicio acceda a esos archivos.</li>
</ul>

<p><img src="/assets/images/SERH3.png" alt="Texto alternativo" /></p>

<ul>
  <li>Los puertos habituales como 80, 443, 8008 y 8443 están etiquetados como http_port_t, lo que autoriza a httpd a utilizarlos.</li>
</ul>

<p><img src="/assets/images/SERH4.png" alt="Texto alternativo" /></p>

<p>Supongamos que decidimos desplegar un sitio personalizado en /var/www/my_site y queremos servirlo desde el puerto 4449, en ese momento, SELinux va a bloquear la operación. ¿Por qué? Porque ni el directorio ni el puerto tienen las etiquetas adecuadas, para que httpd pueda operar correctamente, debemos etiquetar el nuevo directorio con httpd_sys_content_t y asociar el puerto 4449 con el tipo http_port_t.</p>

<p>Este tipo de intervenciones son comunes cuando se trabaja con aplicaciones personalizadas, y lejos de ser una molestia, representan una oportunidad para reforzar la seguridad, asegurándonos de que nada fuera de lo previsto pueda ejecutarse sin autorización explícita.</p>

<p>Afortunadamente, RHEL ofrece herramientas para facilitar este proceso. Por ejemplo, existe un rol de sistema específico para SELinux en Ansible, que permite automatizar la verificación y asignación de etiquetas de forma sencilla y repetible, ideal para despliegues a gran escala o entornos CI/CD, estos son algunos ejemplos del rol rhel-system-roles.selinux.</p>

<p><img src="/assets/images/SERH5.png" alt="Texto alternativo" /></p>

<p><img src="/assets/images/SERH6.png" alt="Texto alternativo" /></p>

<p>### AIDE: Monitorización de la Integridad del Sistema</p>

<p>Mientras SELinux proporciona una defensa proactiva al prevenir acciones no autorizadas, una estrategia completa también necesita detectar cambios que ya han ocurrido, aquí es donde la monitorización de la integridad de archivos se vuelve crucial, uno de los métodos más comunes utilizados por atacantes consiste en modificar archivos o procesos ya existentes dentro del sistema, inyectando código malicioso o alterando configuraciones críticas. Este tipo de cambios, muchas veces sutiles, pueden abrir la puerta a vulnerabilidades graves o ser el inicio de un ataque más amplio.</p>

<p>Para enfrentar este riesgo, RHEL incluye AIDE (Advanced Intrusion Detection Environment), una herramienta que actúa como un sistema de monitoreo de integridad. Su función principal es detectar cualquier cambio no autorizado en los archivos del sistema, lo hace manteniendo una base de datos con el estado esperado de cada archivo y directorio, y comparándola con el estado actual del sistema, así, si se añade, borra, modifica o mueve un archivo, AIDE lo reportará.</p>

<p>Se necesita crear una base de datos inicial que represente el estado actual del sistema</p>

<p><img src="/assets/images/SERH7.png" alt="Texto alternativo" /></p>

<p>Esto generará un archivo con el nombre /var/lib/aide/aide.db.new.gz, esta base de datos contiene hashes y metadatos de los archivos escaneados. En una instalación típica puede incluir más de 50.000 entradas.</p>

<p>Para empezar a usar esta base como referencia para futuros chequeos, simplemente se renombra a aide.db.gz, lo podemos hacer escribiendo en la terminal sudo mv /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz</p>

<p>Con AIDE ya configurado, puedes comenzar a detectar cambios en el sistema en cualquier momento ejecutando aide –-check, puedes configurar en /etc/aide.conf los cambios que quieres que detecte.</p>

<p>En caso de encontrar diferencias entre la base de datos y el sistema actual, AIDE informará detalladamente. En este ejemplo creo un archivo dentro del directorio /root llamado test-aide-demo, al analizar la base de datos automáticamente detecta los cambios e informa.</p>

<p><img src="/assets/images/SERH8.png" alt="Texto alternativo" /></p>

<p>Esto puede indicar que un archivo fue modificado, agregado o incluso solo accedido.</p>

<p>Esto garantiza que cualquier cambio inesperado en el sistema pueda ser detectado rápidamente, permitiendo tomar acciones antes de que se conviertan en una brecha de seguridad.</p>

<h3 id="red-hat-insights-seguridad-predictiva-y-a-escala">Red Hat Insights: Seguridad Predictiva y a Escala</h3>

<p>Mientras que herramientas como SELinux y AIDE aseguran la integridad de un sistema individual, el verdadero desafío empresarial es aplicar esta disciplina a escala. ¿Cómo garantizamos que cientos o miles de sistemas no solo estén protegidos, sino que cumplan con normativas y respondan a las amenazas de forma unificada? Aquí es donde la estrategia de Red Hat escala con Red Hat Insights.</p>

<p>Imaginate un analista de sistemas experto revisando incansablemente cada uno de sus sistemas RHEL, 24/7, este analista no solo detecta problemas, sino que predice fallos y entrega la solución exacta, a menudo como un script de automatización listo para usar, eso es, en esencia, Red Hat Insights</p>

<p>Es un servicio SaaS (Software como Servicio) que se conecta de forma segura a tu entorno RHEL, ya sea on-premise, en la nube pública o en un entorno híbrido, recopila datos anónimos de configuración y telemetría, los compara con una knowledge base masiva curada por los ingenieros de Red Hat y te devuelve recomendaciones personalizadas y priorizadas. Veamos cómo transforma los desafíos diarios en tareas manejables.</p>

<p>No se limita a detectar problemas de seguridad los entiende y te ayuda a resolverlos, su servicio de Vulnerability va mucho más allá de mostrar una lista de CVEs. Por cada vulnerabilidad encontrada, te ofrece contexto claro y útil, qué sistemas están afectados, qué tan grave es (según el estándar CVSS), y lo más importante, si ya existe un exploit conocido que podría ser usado por atacantes, además, guía paso a paso hacia la solución, indicando exactamente qué actualización aplicar o qué recurso técnico consultar para resolver la vulnerabilidad.</p>

<p>Y aquí es donde pasa de ser una herramienta de análisis a una de acción si una vulnerabilidad crítica afecta a decenas o cientos de servidores, corregirla uno por uno sería lento, complicado y con riesgo de error. Insights automatiza ese proceso generando, con un solo clic, un Playbook personalizado. Este no es un guion genérico, sino un conjunto de instrucciones precisas para aplicar solo en los sistemas que tú elijas, con las tareas exactas para solucionar la vulnerabilidad.</p>

<p><img src="/assets/images/SERH9.png" alt="Texto alternativo" /></p>

<p>Es importante destacar que Red Hat Insights es una plataforma multifacética que va mucho más allá de la seguridad, sus servicios también abarcan la gestión proactiva del cumplimiento (Compliance), la optimización del rendimiento y la estabilidad (Advisor) y el análisis de la configuración, sin embargo, en esta ocasión, únicamente mencionamos Vulnerability, ya que aborda de manera directa el dilema del volumen de CVEs y la necesidad de una gestión basada en el riesgo real.</p>

<h2 id="red-hat-ansible-automation-platform-automatización-como-defensa">Red Hat Ansible Automation Platform: Automatización como Defensa</h2>

<p>Tener un plan de remediación automatizado es solo la mitad de la batalla. ¿Cómo se ejecuta ese plan de forma segura, controlada y auditable en toda la empresa? Aquí es donde entra Red Hat Ansible Automation Platform (AAP)</p>

<p>Ansible proporciona un lenguaje común y un motor de automatización unificado que permite a los equipos de seguridad orquestar acciones a través de múltiples productos y proveedores. Transforma tareas complejas y manuales en playbooks simples, legibles por humanos y reutilizables, esto no solo acelera drásticamente la respuesta a incidentes, sino que también fomenta una cultura de colaboración, donde tanto los analistas de seguridad como los operadores de TI pueden entender, verificar y ejecutar las mismas automatizaciones.</p>

<h3 id="orquestación-del-firewall-de-la-detección-a-la-contención">Orquestación del Firewall: De la Detección a la Contención</h3>

<p>El firewall de una organización es su portero digital, el guardián que decide qué tráfico entra y sale de la red, gestionar sus reglas es una de las tareas más críticas y, a menudo, más tediosas, en un entorno empresarial típico, esto implica interactuar con soluciones de proveedores como Check Point, Palo Alto Networks, Fortinet, y otros, cada uno tiene su propia API y su propia lógica. A través de roles y colecciones de contenido certificado, AAP facilita la interacción con distintos proveedores sin necesidad de adaptarse a cada interfaz o API específica.</p>

<p><img src="/assets/images/SERH10.png" alt="Texto alternativo" /></p>

<p>Consideremos un escenario de respuesta a incidentes clásico, un sistema de monitorización detecta un comportamiento sospechoso proveniente de una dirección IP externa. El análisis confirma que se trata de un intento de ataque. La necesidad es inmediata, bloquear esa IP en el firewall perimetral para detener la amenaza en seco.</p>

<p>En un flujo de trabajo tradicional, este sería un proceso manual. Con Ansible, se convierte en una acción instantánea y automatizada. Utilizando el rol ansible_security.acl_manager, un analista puede ejecutar un playbook preaprobado y extraordinariamente simple. Este playbook no requiere conocimientos profundos de la sintaxis específica del firewall simplemente define la intención, se especifican variables claras y concisas como la IP de origen a bloquear, la IP de destino que se está protegiendo, y el tipo de sistema</p>

<p><img src="/assets/images/SERH11.png" alt="Texto alternativo" /></p>

<p>Al ejecutar este playbook, Ansible se conecta a la API del servidor de gestión de Check Point y traduce esta simple intención en las acciones necesarias para crear y aplicar una nueva regla de seguridad, en segundos, la IP del atacante es bloqueada, la amenaza se contiene, y todo el proceso queda registrado y es auditable.</p>

<p>La misma lógica se aplica a la inversa, una vez que el incidente ha sido investigado y resuelto, la misma acl_manager puede ser utilizada con una tarea de unblock_ip para eliminar la regla, asegurando que los bloqueos temporales no se conviertan en problemas operativos permanentes. Esta capacidad de gestionar el ciclo de vida completo de una regla de firewall de forma programática, rápida y consistente es un cambio fundamental para cualquier equipo de seguridad</p>

<h3 id="gestión-de-idps-despliegue-de-reglas-a-escala">Gestión de IDPS: Despliegue de Reglas a Escala</h3>

<p>Si el firewall es ‘el portero’, el Sistema de Detección y Prevención de Intrusiones (IDPS) es el perro guardián que patrulla constantemente la red, buscando patrones de comportamiento malicioso. Herramientas como Snort son increíblemente potentes, pero su eficacia depende enteramente de la calidad y actualidad de sus reglas, cuando surge una nueva amenaza o se descubre una nueva técnica de ataque, es crucial desplegar una nueva firma de detección en todos los sensores de IDPS de la organización de manera rápida y uniforme.</p>

<p>Aquí, de nuevo, el proceso manual es un cuello de botella, iniciar sesión en cada servidor de Snort para editar manualmente los archivos de reglas es lento, propenso a errores de copia y pega, y difícil de escalar, a través de roles como ansible_security.ids_rule, los equipos pueden gestionar las firmas de Snort como si fueran código.</p>

<p>Imaginemos que el equipo de seguridad descubre un nuevo tipo de ataque que intenta acceder al archivo /etc/passwd a través de peticiones web, se necesita una regla para detectar este patrón de inmediato, en lugar de enviar un correo electrónico con instrucciones, se crea un playbook.</p>

<p>Este playbook es un ejemplo de claridad y potencia, primero, se asegura de que la automatización se ejecute con los privilegios necesarios en el servidor Snort (become: true). Luego, especifica el proveedor (ids_provider: snort). La parte más importante es la propia regla, definida en la variable ids_rule en la sintaxis nativa de Snort, pero gestionada y desplegada por Ansible. El playbook también indica exactamente dónde debe escribirse la regla (ids_rules_file) y que su estado debe ser presente, es decir, que se cree si no existe.</p>

<p><img src="/assets/images/SERH12.png" alt="Texto alternativo" /></p>

<p>Con la ejecución de ansible-navigator, este playbook se conecta a todos los servidores Snort definidos en el inventario y añade la nueva regla de forma atómica y consistente. La verificación es tan simple como conectarse a uno de los servidores y comprobar que la nueva línea ha sido añadida al final del archivo de reglas.</p>

<p>Los ejemplos de gestión de firewalls y IDPS son potentes por sí solos, pero su verdadero valor transformador se revela cuando se combinan en flujos de trabajo de seguridad orquestados. Ansible Automation Platform no solo ejecuta tareas aisladas, permite construir una respuesta a incidentes coherente y de múltiples pasos que se ejecuta a la velocidad de la máquina, no a la velocidad humana.</p>

<p>Este nivel de automatización reduce el tiempo medio de respuesta (MTTR) de horas a meros segundos. Libera a los analistas de seguridad de tareas repetitivas y les permite centrarse en actividades de mayor valor, como la caza de amenazas y el análisis estratégico</p>

<h2 id="red-hat-openshift-seguridad-en-la-cadena-de-suministro-de-software">Red Hat OpenShift: Seguridad en la Cadena de Suministro de Software</h2>

<p>Hemos asegurado el sistema operativo y automatizado su gestión, pero las aplicaciones modernas ya no viven ahí, hoy se ejecutan en contenedores y se despliegan en nubes híbridas, por eso, la estrategia de seguridad de Red Hat se extiende naturalmente a esta capa con ‘Red Hat OpenShift’.</p>

<p>En este apartado, nos enfocaremos en un aspecto clave de esa seguridad, la protección de la cadena de suministro de software (software supply chain). No cubriremos toda la seguridad de OpenShift, sino cómo garantizar que, desde la construcción hasta el despliegue, las aplicaciones sean legítimas, confiables y seguras.</p>

<h3 id="construyendo-una-cadena-de-suministro-confiable">Construyendo una Cadena de Suministro Confiable</h3>

<p>El incidente XZ backdoor fue una llamada de atención global, la seguridad no puede empezar en el servidor de producción, sino desde el origen mismo del software, para el mundo de los contenedores, esto significa proteger toda la cadena de suministro, desde la construcción de la imagen hasta su despliegue final.</p>

<p>Construir una cadena de suministro segura y confiable requiere cuidar cada etapa del ciclo de vida del software, desde la escritura del código hasta su puesta en producción.</p>

<p>Todo comienza con la elección de una imagen base. Hoy existen miles de imágenes en repositorios públicos, pero no todas ofrecen el mismo nivel de calidad, mantenimiento o seguridad. Por eso, es responsabilidad de cada equipo elegir cuidadosamente.</p>

<p><img src="/assets/images/SERH13.png" alt="Texto alternativo" /></p>

<p>Muchas organizaciones prefieren partir de una imagen base mínima, confiable y mantenida, como las Red Hat Universal Base Images (UBI), estas contienen solo lo esencial, lo que permite mantener el control total para aplicar parches rápido y reducir la superficie de ataque, agregando solo los frameworks y librerías que la aplicación necesita.</p>

<p>Pero, aunque una aplicación pase todas las pruebas de seguridad y funcione perfectamente, ¿cómo estar seguros de que realmente fue construida con nuestro código legítimo? Un atacante podría haber insertado código malicioso que robe información sin alterar el comportamiento visible.</p>

<p>Antes, documentos físicos se protegían con sellos que garantizaban su integridad. Hoy, esa función la cumplen las firmas criptográficas.</p>

<p>Firmar digitalmente el código fuente es un primer paso fundamental. Cada cambio debe llevar una firma que confirme la identidad del autor y asegure que el código no fue alterado. Las pipelines de CI/CD deben rechazar automáticamente cualquier commit sin firma válida.</p>

<p>Del mismo modo, las imágenes de contenedor deben firmarse en el momento de su creación, para asegurar que provienen de una fuente confiable y no han sido modificadas. Plataformas como OpenShift pueden validar estas firmas antes del despliegue, permitiendo solo la ejecución de imágenes autorizadas.</p>

<p><img src="/assets/images/SERH14.png" alt="Texto alternativo" /></p>

<h3 id="escaneo-continuo-y-sbom-visibilidad-y-control">Escaneo Continuo y SBOM: Visibilidad y Control</h3>

<p>Incluso siguiendo estas mejores prácticas, el riesgo de vulnerabilidades persiste, estas pueden venir desde la imagen base o surgir durante la construcción de la aplicación.</p>

<p>Por eso, es crucial escanear las imágenes en distintos puntos, revisar periódicamente las imágenes base y, si se detecta alguna vulnerabilidad, reconstruirlas y actualizarlas, además, escanear cada nueva imagen antes de pasarla a producción, bloqueando cualquier imagen con fallas críticas para devolverla al equipo de desarrollo.</p>

<p>Para tener visibilidad total sobre los componentes que integran una imagen, es fundamental generar un Software Bill of Materials (SBOM), que documenta todas las librerías, frameworks y dependencias, facilitando auditorías y evaluaciones de riesgo. Este inventario debe generarse y almacenarse junto con la imagen en el registro de contenedores.</p>

<h3 id="la-solución-integrada-red-hat-trusted-software-supply-chain">La Solución Integrada: Red Hat Trusted Software Supply Chain</h3>

<p>Para enfrentar todos estos desafíos, Red Hat ofrece la Red Hat Trusted Software Supply Chain, una colección de soluciones integradas que incorporan seguridad en cada etapa del ciclo de vida de las aplicaciones nativas de la nube.</p>

<p><img src="/assets/images/SERH15.png" alt="Texto alternativo" /></p>

<p>En lugar de que los equipos deban armar y asegurar por su cuenta una cadena de herramientas y componentes dispares, Red Hat entrega una plataforma completa, fácil de usar y cohesiva, que conecta todo de forma segura y confiable.</p>

<p>La plataforma integra un conjunto de herramientas diseñadas para cubrir todo el ciclo de vida del software, desde el desarrollo hasta la producción, asegurando agilidad y confianza en cada etapa. Para la fase de desarrollo, Red Hat Developer Hub actúa como un portal centralizado que simplifica la creación de aplicaciones, permitiendo a los equipos enfocarse en el código en lugar de la complejidad de la infraestructura. Este proceso se construye sobre las Universal Base Images, que ofrecen un cimiento fiable y seguro para minimizar riesgos desde el inicio.</p>

<p>Para asegurar la cadena de suministro, Trusted Artefact Signer aplica una firma digital al software para validar su autenticidad. A su vez, Trusted Profile Analyzer evalúa de forma inteligente las dependencias para identificar solo las vulnerabilidades que suponen un riesgo real. La gestión de estas imágenes se centraliza en Quay, un registro que las almacena de forma segura y las analiza continuamente en busca de amenazas.</p>

<p>Finalmente, OpenShift actúa como el motor de orquestación que automatiza el despliegue y la gestión de las aplicaciones, mientras que Advanced Cluster Security añade una capa de protección en tiempo de ejecución, monitoreando el entorno y garantizando el cumplimiento de las políticas de seguridad.</p>

<p>Con esta oferta, Red Hat acompaña a los equipos para construir, verificar y desplegar software seguro y confiable, desde el primer código hasta la aplicación en producción.</p>

<h2 id="conclusiones-y-reflexiones-finales">Conclusiones y Reflexiones Finales</h2>

<p>El modelo open source, por su naturaleza transparente, tiende a reportar más vulnerabilidades que el software propietario, lo cual no significa que sea menos seguro, sino que permite un análisis más honesto y riguroso del riesgo real. En lugar de dejarnos llevar por el número de CVEs publicados, debemos cambiar el foco hacia la verdadera prioridad, entender qué vulnerabilidades representan un riesgo real y cuáles no. Este enfoque basado en el riesgo y no en la cantidad es indispensable en un mundo donde la estrategia de parches tradicional ya no es suficiente.</p>

<p>Red Hat demuestra que no basta con consumir software libre, sino que se requiere un enfoque proactivo y estructurado para convertirlo en una verdadera plataforma empresarial segura. Herramientas como las que hemos hablado aquí, permiten construir una defensa integral que abarca desde el control de accesos, hasta la seguridad en entornos de contenedores. Todo esto bajo una misma visión coherente, donde la protección se integra desde la creación del software hasta su despliegue.</p>]]></content><author><name>Xavi Vico Marti</name></author><category term="Seguridad" /><category term="Red Hat" /><category term="Open Source" /><category term="RHEL" /><category term="SELinux" /><category term="Ansible" /><category term="OpenShift" /><category term="CVE" /><category term="Seguridad Empresarial" /><summary type="html"><![CDATA[Exploramos cómo Red Hat refuerza la seguridad empresarial más allá del software de código abierto, integrando RHEL, SELinux, Ansible, Insights y OpenShift.]]></summary></entry></feed>